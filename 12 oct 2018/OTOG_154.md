### Range sum query 
#### by ชาวบ้านเลเวล99
​	โจทย์ข้อนี้ถามว่า มีตัวเลข n ตัว เรียงใน array 1  มิติ ต้องการทราบผลรวมของตัวเลขทุกตัวตั้งแต่อินเดกซ์ l ถึง r (0 <= l <= r < n) 
​	**วิธีแรกๆที่น้อง ๆ จะคิดถึงคือ “วน for หา sum ไปเลยพี่!”** แต่หากส่งไปแบบนั้นคงเห็นตัว T ตัวใหญ่ ๆ อัดหน้ากลับมา เนื่องจากมันเสียเวลามากในการวน for ทุกครั้งที่โจทย์ถาม 0

​	**คีย์เวิร์ดของเราคือต้องทราบคำตอบจากการวน for เพียงครั้งเดียว** โดยวิธีก็ง่ายมากครับ หากใครเคยเรียนสถิติมาคงจะรู้จักสิ่งที่เรียกว่า “ความถี่สะสม” มันก็คือเราจะเก็บค่าผลรวมของข้อมูลในอินเดกซ์แรกถึงอินเดกซ์ใดๆ ทุกอินเดกซ์ วิธีนี้เราสามารถทำได้ตอนเรารับค่ามาแล้ว ดังนี้

``` c
int a[21];
for(int i=1 i<=0; i++)
{
	scanf(“%d”,&a[i]);
    if (i>0)
    	a[i] += a[i-1];
}
```

​	แล้วเราจะรู้ได้ไง เพราะเราเริ่มบวกที่อินเดกซ์ l ซึ่งถ้า l = 0 เราก็สามารถตอบโดยใช้ a[r] ได้เลย แต่ถ้า l > 0 นี่เราก็สามารถคำนวณได้เพียงครั้งเดียวเลยคือ a[r+1] - a[l] แค่นี้เเหละ
**คำนวณ**
ให้ s_k แทนผลรวมตั้งแต่อินเดกซ์แรกถึง k
ให้ a_k แทนข้อมูลอินเดกซ์ k

``` text
s_r	= 	a_1+a_2+a_3+...+a_r
	= 	a_1+a_2+a_3+...+a_(l-1)+a_l+...+a_r
	= 	s_(l-1) + คำตอบที่เราต้องการ
```

**ดังนั้น คำตอบที่เราต้องการจึงเท่ากับ s_r-s_(l-1) นั่นเอง**
​	เนื่องจากข้อนี้ค่อนข้างใช้เทคนิค โค้ดจึงไม่ได้เขียนยากเย็นเลย เพียงแค่วน for รับค่าเท่านั้นเอง
ข้อนี้ใช้เทคนิคที่เรียกว่า prefix sum, accumulate_sum หรือบางคนเรียกว่า quick sum (ซึ่งพี่ไม่ค่อยชอบชื่อนี้เท่าไหร่ มันไม่เพราะ) ซึ่งเป็นหนึ่งใน dynamic programming ที่ควรรู้ไว้นะครับ

pannxe : โค้ตนะครับ ดูแล้วศึกษา แล้วเอาแนวคิดไปเขียนของตัวเองนะ

``` c
#include <stdio.h>

void pfx_sum() {
    // กำหนดค่าแรกสุดเป็น 0 ไว้ก่อน (S_0 = 0)
    long long S[100020];
    S[0] = 0;
    
    int n, q;
    scanf("%d %d", &n, &q);

    // วนบวกค่า prefix sum เพียงแต่ของพี่จะเลื่อนไปอีกช่องหนึ่งจากของปั้น
    // ฉะนั้น index ของพี่จะเริ่มที่ 1 แทนที่จะเป็น 0
    for(int i=1; i<=n; i++) {
        scanf("%lld", &S[i]);
        S[i] += S[i-1];
    }
    // วน q ครั้ง
    while(q--) {
        int l, r;
        scanf("%lld %lld", &l, &r);
        
        // อย่างที่บอกว่าพี่จะเริ่มที่ 1 ฉะนั้นจะเป็น S_(r+1) - S_l แทน
        // แบบนี้จะแก้ปัญหาถ้า l เป็น 0 แล้ว l-1 = -1 ซึ่งทำให้โปรแกรม Error
        printf("%lld\n", S[r+1]-S[l]);
    }
}

int main() {
    int t;
    scanf("%d", &t);
    // เรียกฟังก์ชันที่ใช้แก้โจทย์ t ครั้ง
    while(t--) {
        pfx_sum();
        // ขึ้นบรรทัดใหม่ทุกครั้งที่จบ test case
        printf("\n");
    }
    return 0;
}

```

**Pun the villager** 	- *Editorial*
**pannxe** 			- Code
