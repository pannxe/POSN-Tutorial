### Trigger finger

#### by pannxe

แนวคิดคือดูว่าถ้ามีตัวอักษรพิมพ์ใหญ่อยู่ติดกัน 2 ตัวหรือมากกว่าให้ใช้ Caps-lock แทน แต่ก็มีกรณีที่ต้องระวังคือหากว่ามีอักษรพิมพ์เล็กตัวเดียวขั้นพิมพ์ใหญ่ที่ติดกันหลาย ๆ ตัว ให้ใช้ Shift เพื่อกลับไปเป็นพิมพ์เล็กแทนที่จะปิด Caps-lock และต้องกดเปิดใหม่ เช่น

a**AAA**a**AAA**a
หากคิดแค่ว่าถ้ามีตัวใหญ่เกิน 2 ตัวให้กด Caps-lock แล้ว จะต้องใช้ 4 ครั้ง คือกดเปิดและปิด 2 ครั้ง แต่เราสามารถใช่ปุ่ม Shift เพื่อพิมพ์ a ตรงกลางได้ ก็จะเหลือเพียง 3 ครั้ง

a**AAA**aa**AAA**a
กรณีนี้จะกด Shift ค้างหรือปิด Caps-lock ก็มีค่าเท่ากัน (2)

a**AAA**aaa**AAA**a
กรณีนี้ปิด Caps-lock ไปเลยดีกว่า (ปิด-เปิดใหม่ใช้ 2 แต่กด Shift แช่ใช้ 3)

``` c
#include <stdio.h>

#define upper(x) ((x)>='A' && (x)<='Z')

char s[1000020];
int count, streak, i;

int main() {
    scanf("%s", s);
    for(; s[i] != '\0'; i++) {
        // ถ้าเป็นพิมพ์ใหญ่ ให้เพิ่มจำนวนตัวพิมพ์ใหญ่ที่ติดกัน 1 แล้วไปตัวถัดไปเลย
        if(upper(s[i])) {
            streak++;
            continue;
        }
        // ถ้ามีตัวพิมพ์ใหญ่แค่ตัวเดียวให้ใช้ Shift (1 ครั้ง)
        if (streak == 1) {
            count++;
        }
        // ถ้ามีตัวพิมพ์ใหญ่มากกว่าแค่ 1
        else if (streak > 1) {
            // เช็กว่าถ้าเป็นแค่อักษรพิมพ์เล็กตัวเดียวขั้นพิมพ์ใหญ่ก็ให้ใช้ shift พอ ไม่ต้อง
            // ปิด Caps-lock จะประหยัดการกดไปได้ 1 ครั้ง
            if (upper(s[i+1])) {
                count++;
                continue;
            }
            // กดปิดกับเปิด Caps-lock เป็น 2 ครั้ง และปรับจำนวนพิมพ์ใหญ่เป็น 0 ใหม่
            else {
                count += 2;
            }
        }
        //เมื่อเป็นตัวเล็กให้ล้างค่าจำนวนตัวพิมพ์ใหญ่เป็น 0 ให้หมด
        streak = 0;
    }
    // ในลูปด้านบน ถ้าตัวพิมพ์ใหญ่เป็นตัวสุดท้าย จะไม่เพิ่มจำนวนให้ เลยมาเช็กเอาทีหลัง 
    // แต่เราไม่จำเป็นต้องกดปิด  Caps-lock เราเลยเพิ่มแค่ 1 ไม่ว่าจะมีกี่ตัวติดกันมาก่อน
    if (upper(s[i-1])) {
        count++;
    }
    printf("%d", count);
    return 0;
}
```

